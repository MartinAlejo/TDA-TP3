\section*{Consigna}
Para los primeros dos puntos considerar la versión de decisión del problema de La Batalla Naval:  
Dado un tablero de $n \times m$ casilleros, y una lista de $k$ barcos (donde el barco $i$ tiene $b_i$ de largo), una lista de restricciones para las filas (donde la restricción $j$ corresponde a la cantidad de casilleros a ser ocupados en la fila $j$) y una lista de restricciones para las columnas (símil filas, pero para columnas), ¿es posible definir una ubicación de dichos barcos de tal forma que se cumplan con las demandas de cada fila y columna, y las restricciones de ubicación?

\begin{itemize}
    \item Demostrar que el Problema de la Batalla Naval se encuentra en NP.
    \item Demostrar que el Problema de la Batalla Naval es, en efecto, un problema NP-Completo.  
    Si se hace una reducción involucrando un problema no visto en clase, agregar una (al menos resumida) demostración que dicho problema es NP-Completo.  
    Para esto, recomendamos ver ya sea los problemas 3-Partition o Bin-Packing, ambos en su versión unaria. Si bien sería tentador utilizar 2-Partition, esta reducción no sería correcta. En caso de querer saber más al respecto, consultarnos :-)
    \item Escribir un algoritmo que, por backtracking, obtenga la solución óptima al problema (valga la redundancia) en la versión de optimización:  
    Dado un tablero de $n \times m$ casilleros, y una lista de $k$ barcos (donde el barco $i$ tiene $b_i$ de largo), una lista de las demandas de las $n$ filas y una lista de las $m$ demandas de las columnas, dar la asignación de posiciones de los barcos de tal forma que se reduzca al mínimo la cantidad de demanda incumplida.  
    Pueden no utilizarse todos los barcos. Si simplemente no se cumple que una columna que debería tener 3 casilleros ocupados tiene 1, entonces contará como 2 de demanda incumplida. Por el contrario, no está permitido exceder la cantidad demandada.  
    Generar sets de datos para corroborar su correctitud, así como tomar mediciones de tiempos.
    \item (opcional) Escribir un modelo de programación lineal que resuelva el problema de forma óptima. Ejecutarlo para los mismos sets de datos para corroborar su correctitud. Tomar mediciones de tiempos y compararlas con las del algoritmo que implementa Backtracking.
    \item John Jellicoe (almirante de la Royal Navy durante la batalla de Jutlandia) nos propone el siguiente algoritmo de aproximación:  
    Ir a la fila/columna de mayor demanda, y ubicar el barco de mayor longitud en dicha fila/columna en algún lugar válido. Si el barco de mayor longitud es más largo que dicha demanda, simplemente saltearlo y seguir con el siguiente.  
    Volver a aplicar hasta que no queden más barcos o no haya más demandas a cumplir.

    Este algoritmo sirve como una aproximación para resolver el problema de La Batalla Naval. Implementar dicho algoritmo, analizar su complejidad y analizar cuán buena aproximación es.  
    Para esto, considerar lo siguiente:  
    Sea $I$ una instancia cualquiera del problema de La Batalla Naval, y $z(I)$ una solución óptima para dicha instancia, y sea $A(I)$ la solución aproximada, se define $\frac{A(I)}{z(I)} \leq r(A)$ para todas las instancias posibles.  
    Calcular $r(A)$ para el algoritmo dado, demostrando que la cota está bien calculada.  
    Realizar mediciones utilizando el algoritmo exacto y la aproximación, con el objetivo de verificar dicha relación.  
    Realizar también mediciones que contemplen volúmenes de datos ya inmanejables para el algoritmo exacto, a fin de corroborar empíricamente la cota calculada anteriormente.
    \item (opcional) Implementar alguna otra aproximación (o algoritmo greedy) que les parezca de interés. Comparar sus resultados con los dados por la aproximación del punto anterior. Indicar y justificar su complejidad. No es obligatorio hacer este punto para aprobar el trabajo práctico (pero sí resta puntos no hacerlo).
    \item Agregar cualquier conclusión que parezca relevante.
\end{itemize}













